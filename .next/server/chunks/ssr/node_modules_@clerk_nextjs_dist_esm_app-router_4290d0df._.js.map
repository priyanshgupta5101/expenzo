{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/Expenzo/node_modules/%40clerk/nextjs/dist/esm/app-router/keyless-actions.js"],"sourcesContent":["\"use server\";\r\nimport { cookies, headers } from \"next/headers\";\r\nimport { redirect, RedirectType } from \"next/navigation\";\r\nimport { errorThrower } from \"../server/errorThrower\";\r\nimport { detectClerkMiddleware } from \"../server/headers-utils\";\r\nimport { getKeylessCookieName, getKeylessCookieValue } from \"../server/keyless\";\r\nimport { canUseKeyless } from \"../utils/feature-flags\";\r\nconst keylessCookieConfig = {\r\n  secure: false,\r\n  httpOnly: false,\r\n  sameSite: \"lax\"\r\n};\r\nasync function syncKeylessConfigAction(args) {\r\n  const { claimUrl, publishableKey, secretKey, returnUrl } = args;\r\n  const cookieStore = await cookies();\r\n  const request = new Request(\"https://placeholder.com\", { headers: await headers() });\r\n  const keyless = await getKeylessCookieValue((name) => {\r\n    var _a;\r\n    return (_a = cookieStore.get(name)) == null ? void 0 : _a.value;\r\n  });\r\n  const pksMatch = (keyless == null ? void 0 : keyless.publishableKey) === publishableKey;\r\n  const sksMatch = (keyless == null ? void 0 : keyless.secretKey) === secretKey;\r\n  if (pksMatch && sksMatch) {\r\n    return;\r\n  }\r\n  cookieStore.set(\r\n    await getKeylessCookieName(),\r\n    JSON.stringify({ claimUrl, publishableKey, secretKey }),\r\n    keylessCookieConfig\r\n  );\r\n  if (detectClerkMiddleware(request)) {\r\n    redirect(`/clerk-sync-keyless?returnUrl=${returnUrl}`, RedirectType.replace);\r\n    return;\r\n  }\r\n  return;\r\n}\r\nasync function createOrReadKeylessAction() {\r\n  if (!canUseKeyless) {\r\n    return null;\r\n  }\r\n  const result = await import(\"../server/keyless-node.js\").then((m) => m.createOrReadKeyless()).catch(() => null);\r\n  if (!result) {\r\n    errorThrower.throwMissingPublishableKeyError();\r\n    return null;\r\n  }\r\n  const { clerkDevelopmentCache, createKeylessModeMessage } = await import(\"../server/keyless-log-cache.js\");\r\n  clerkDevelopmentCache == null ? void 0 : clerkDevelopmentCache.log({\r\n    cacheKey: result.publishableKey,\r\n    msg: createKeylessModeMessage(result)\r\n  });\r\n  const { claimUrl, publishableKey, secretKey, apiKeysUrl } = result;\r\n  void (await cookies()).set(\r\n    await getKeylessCookieName(),\r\n    JSON.stringify({ claimUrl, publishableKey, secretKey }),\r\n    keylessCookieConfig\r\n  );\r\n  return {\r\n    claimUrl,\r\n    publishableKey,\r\n    apiKeysUrl\r\n  };\r\n}\r\nasync function deleteKeylessAction() {\r\n  if (!canUseKeyless) {\r\n    return;\r\n  }\r\n  await import(\"../server/keyless-node.js\").then((m) => m.removeKeyless()).catch(() => {\r\n  });\r\n  return;\r\n}\r\nasync function detectKeylessEnvDriftAction() {\r\n  if (!canUseKeyless) {\r\n    return;\r\n  }\r\n  try {\r\n    const { detectKeylessEnvDrift } = await import(\"../server/keyless-telemetry.js\");\r\n    await detectKeylessEnvDrift();\r\n  } catch {\r\n  }\r\n}\r\nexport {\r\n  createOrReadKeylessAction,\r\n  deleteKeylessAction,\r\n  detectKeylessEnvDriftAction,\r\n  syncKeylessConfigAction\r\n};\r\n"],"names":[],"mappings":";;;;;;;IAiFE,4BAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA","debugId":null}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///D:/Expenzo/node_modules/%40clerk/nextjs/src/app-router/client/keyless-creator-reader.tsx"],"sourcesContent":["import { useSelectedLayoutSegments } from 'next/navigation';\nimport React, { useEffect } from 'react';\n\nimport type { NextClerkProviderProps } from '../../types';\nimport { createOrReadKeylessAction } from '../keyless-actions';\n\nexport const KeylessCreatorOrReader = (props: NextClerkProviderProps) => {\n  const { children } = props;\n  const segments = useSelectedLayoutSegments();\n  const isNotFoundRoute = segments[0]?.startsWith('/_not-found') || false;\n  const [state, fetchKeys] = React.useActionState(createOrReadKeylessAction, null);\n  useEffect(() => {\n    if (isNotFoundRoute) {\n      return;\n    }\n    React.startTransition(() => {\n      fetchKeys();\n    });\n  }, [isNotFoundRoute]);\n\n  if (!React.isValidElement(children)) {\n    return children;\n  }\n\n  return React.cloneElement(children, {\n    key: state?.publishableKey,\n    publishableKey: state?.publishableKey,\n    __internal_keyless_claimKeylessApplicationUrl: state?.claimUrl,\n    __internal_keyless_copyInstanceKeysUrl: state?.apiKeysUrl,\n    __internal_bypassMissingPublishableKey: true,\n  } as any);\n};\n"],"names":[],"mappings":";;;;AAAA,SAAS,iCAAiC;AAC1C,OAAO,SAAS,iBAAiB;AAGjC,SAAS,iCAAiC;;;;;AAEnC,MAAM,yBAAyB,CAAC,UAAkC;IANzE,IAAA;IAOE,MAAM,EAAE,QAAA,CAAS,CAAA,GAAI;IACrB,MAAM,eAAW,+JAAA,CAA0B;IAC3C,MAAM,kBAAA,CAAA,CAAkB,KAAA,QAAA,CAAS,CAAC,CAAA,KAAV,OAAA,KAAA,IAAA,GAAa,UAAA,CAAW,cAAA,KAAkB;IAClE,MAAM,CAAC,OAAO,SAAS,CAAA,GAAI,gNAAA,CAAM,cAAA,CAAe,sOAAA,EAA2B,IAAI;IAC/E,IAAA,kNAAA,EAAU,MAAM;QACd,IAAI,iBAAiB;YACnB;QACF;QACA,gNAAA,CAAM,eAAA,CAAgB,MAAM;YAC1B,UAAU;QACZ,CAAC;IACH,GAAG;QAAC,eAAe;KAAC;IAEpB,IAAI,CAAC,gNAAA,CAAM,cAAA,CAAe,QAAQ,GAAG;QACnC,OAAO;IACT;IAEA,OAAO,gNAAA,CAAM,YAAA,CAAa,UAAU;QAClC,KAAK,SAAA,OAAA,KAAA,IAAA,MAAO,cAAA;QACZ,gBAAgB,SAAA,OAAA,KAAA,IAAA,MAAO,cAAA;QACvB,+CAA+C,SAAA,OAAA,KAAA,IAAA,MAAO,QAAA;QACtD,wCAAwC,SAAA,OAAA,KAAA,IAAA,MAAO,UAAA;QAC/C,wCAAwC;IAC1C,CAAQ;AACV","debugId":null}}]
}